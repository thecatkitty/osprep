#!/bin/bash -l

# Author      : Mateusz Karcz
# Last edited : May 2018
# Version     : 0.1.1805
#
# Description : A tool for downloading and configuring boot disks of hipster
#               operating systems.
#
# Licensed under the MIT License.

PROGRAM_NAME="Celones Operating System Preparation Utility"
PROGRAM_VERSION="0.1.1805"

HTTP_USER_AGENT="Celones-OSPrep/$PROGRAM_VERSION"

NC="\033[0m"
BOLD="\033[1m"
GREEN="\033[0;32m"

OPT_FORMAT="text"
OPT_LOCAL=false
REPO_URL="http://pkg.svc.celones.pl/osprep/"
REPO_LOCAL="$HOME/.osprep/"

############################### HELPER ROUTINES ################################
function check_wget {
  if [ -z `command -v wget` ]; then
    echo "This command requires wget, but it hasn't been found!" >&2
    exit 1
  fi
}

function check_make {
  if [ -z `command -v make` ]; then
    echo "This command requires GNU Make, but it hasn't been found!" >&2
    exit 1
  fi
}

function http_header {
  # $URL - remote resource
  # $1   - name of the HTTP header
  wget -S --spider -U "$HTTP_USER_AGENT" "$URL" 2>&1 | grep "$1: " | sed -e 's/^ *[^:]\+: //'
}

function http_download {
  # $URL  - remote resource
  # $FILE - output file name
  mkdir -p `dirname "$FILE"`
  wget --no-verbose --show-progress --progress=bar -U "$HTTP_USER_AGENT" -O "$FILE" "$URL"
  if [ $? -ne 0 ]; then rm -f "$FILE"; fi
}

function download_gauge {
  # $URL  - remote resource
  # $FILE - output file name
  wget --progress=dot -U "$HTTP_USER_AGENT" -O "$FILE" "$URL" 2>&1 \
  | grep "%" | sed -u -e 's/^ *[^ ]\+[\. ]\+//g' | sed -u -e 's/%.*//' \
  | dialog \
  --backtitle "$PROGRAM_NAME" \
  --title "Downloading" \
  --gauge "$URL" 10 100
  if [ $? -ne 0 ]; then rm -f "$FILE"; fi
}

function rdn_to_path {
  IFS='~' read -r -a SPLIT <<< "$1"
  if [ -n "${SPLIT[1]}" ]; then
    sed -e 's/\./\//g' <<< "${SPLIT[0]}" | sed -e "s/$/~${SPLIT[1]}/"
  else
    sed -e 's/\./\//g' <<< "$1"
  fi
}

function mk_to_rdn {
  echo -n $1 | sed -e 's/\.osprep\/settings\///g' | sed -e 's/\.mk$//g' | sed -e 's/\//./g'
}

function trim {
  # $1 - string for the whitespace removal
  echo -n "$1" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//'
}

function print_list {
  # $FILE - input CSV file
  if [ $OPT_FORMAT == "csv" ]; then cat "$FILE"

  else
    while read LINE; do
      IFS=';' read -r -a RECORD <<< "$LINE"
      echo -e "${GREEN}${RECORD[0]}${NC} ${RECORD[1]}"
      echo -e "  ${BOLD}${RECORD[2]}:${NC} ${RECORD[3]}"
      echo ""
    done < "$FILE"
  fi
}

function find_package {
  # $FILE - CSV file
  # $1    - package to be found

  FOUND=''
  IFS='~' read -r -a PACK_NAME <<< "$1"
  if [ "${PACK_NAME[1]}" ]; then

    while read LINE; do
      IFS=';' read -r -a RECORD <<< "$LINE"
      if [ "${RECORD[0]}" == "${PACK_NAME[0]}" \
        -a "${RECORD[1]}" == "${PACK_NAME[1]}" ]; then

        FOUND="${RECORD[0]}~${RECORD[1]}"
        return

      fi
    done < "$FILE"

    return

  else

    while read LINE; do
      IFS=';' read -r -a RECORD <<< "$LINE"
      if [ "${RECORD[0]}" == "$1" ]; then
        FOUND="${RECORD[0]}~${RECORD[1]}"
      fi
    done < "$FILE"

    return

  fi
}

function download_package {
  # $FILE - output file path
  # $URL  - remote repository path
  if [ -f "$FILE" ]; then
    HTTP_LAST_MODIFIED=`http_header "Last-Modified"`
    if [ $(date -d "$HTTP_LAST_MODIFIED" +%s) -gt $(stat -c %Y "$FILE") ]; then
      rm "$FILE"
    else
      echo "Package up to date, skipping."
    fi
  fi

  if [ ! -f "$FILE" ]; then
    echo "Downloading the package."
    http_download
    if [ -f "$FILE" ]; then
      echo "Package download completed."
    else
      echo "Couldn't download package!" >&2
      exit 1
    fi
  fi
}

function extract_package {
  # $FILE       - package file path
  # $TARGET_DIR - extraction output directory
  mkdir -p "$TARGET_DIR"
  tar -xJf "$FILE" -C "$TARGET_DIR" --verbose
}

function prepare_apply {
  # $MAKEDIR - Makefiles directory
  # $TARGET  - target directory
  # $1       - package ID
  GENERAL_PATH=`rdn_to_path "$1"`
  MAKEFILE_PATH="${MAKEDIR}/${GENERAL_PATH}"
  BASE=`base`

  mkdir -p "$MAKEFILE_PATH"

  echo "HTTPDOWNLOAD = wget --no-verbose --show-progress --progress=bar -U \"$HTTP_USER_AGENT\" -O" > "${MAKEFILE_PATH}/Makefile"
  echo "OUT = \"`realpath "$TARGET"`\"" >> "${MAKEFILE_PATH}/Makefile"
  echo "REPO = ${REPO_LOCAL}" >> "${MAKEFILE_PATH}/Makefile"
  echo "MOUNT = .osprep/mount" >> "${MAKEFILE_PATH}/Makefile"
  echo "BASE_SETTINGS = .osprep/settings/`rdn_to_path $BASE`.mk" >> "${MAKEFILE_PATH}/Makefile"
  echo "" >> "${MAKEFILE_PATH}/Makefile"
  
  cat ".osprep/settings/${GENERAL_PATH}.mk" >> "${MAKEFILE_PATH}/Makefile"
  echo "" >> "${MAKEFILE_PATH}/Makefile"
  cat "${REPO_LOCAL}${GENERAL_PATH}/apply.mk" >> "${MAKEFILE_PATH}/Makefile"
  echo "" >> "${MAKEFILE_PATH}/Makefile"
}

function mk_to_csv {
  # $FILE - package settings .mk file
  while read LINE; do
    RDN=`mk_to_rdn "$FILE" | sed -e 's/\s//g'`
    if [ `echo "$LINE" | sed -e 's/\s//g'` ]; then
      IFS='#' read -r -a SPLIT <<< "$LINE"
      STATEMENT=`trim "${SPLIT[0]}"`
      COMMENT="${SPLIT[1]}"
      if [ "$STATEMENT" ]; then
        IFS='=' read -r -a SPLIT <<< "$STATEMENT"

        KEY=`trim "${SPLIT[0]}"`
        VALUE=`trim "${SPLIT[1]}"`

        echo -n "${RDN}::${KEY};${VALUE}"

        if [ "`echo $COMMENT | grep '^%[^\s] '`" ]; then

          IFS='	' read -r -a PARAMETERS <<< "${COMMENT:3}"

          CAPTION="`trim "${PARAMETERS[0]}"`"
          if [ "$CAPTION" ]; then

            echo -n ";$CAPTION"

            TYPECHAR=`echo $COMMENT | grep -o '^%.' | grep -o '.$'`
            if [ $TYPECHAR == 'T' ]; then echo -n ';text'
            elif [ $TYPECHAR == 'C' ]; then echo -n ';check'

            elif [ $TYPECHAR == 'O' ]; then
              echo -n ';option;'
              read -r -a OPTIONS <<< "${PARAMETERS[1]}"

              i=0
              while [ "${OPTIONS[$i]}" ]; do
                if [ $i -gt 0 ]; then echo -n ','; fi
                echo -n ${OPTIONS[$i]}
                let i++
              done
            fi

          else
            echo -n ';$KEY;text'
          fi

        else
          echo -n ';$KEY;text'
        fi
        echo ""
      fi
    fi
  done < "$FILE"
}

function record_to_mk {
  # $RECORD - settings record
  echo -n `echo ${RECORD[0]} | sed -e 's/.*:://'`
  echo -n ' = '
  echo -n "${RECORD[1]}  "
  echo -n '%'
  if [ ${RECORD[3]} == 'text' ]; then echo -n 'T'
  elif [ ${RECORD[3]} == 'check' ]; then echo -n 'C'
  elif [ ${RECORD[3]} == 'option' ]; then echo -n 'O'
  else
    echo "Unknown setting value type \`${RECORD[3]}\`!" >&2
    exit 1
  fi
  echo -n " ${RECORD[2]}"

  if [ ${RECORD[3]} == 'check' ]; then
    echo -en '	'
    echo -n "${RECORD[4]}" | sed -e 's/,/ /g'
  fi
  echo ""
}

function beautify_settings {
  # stdin - CSV
  while read LINE; do
    IFS=';' read -r -a RECORD <<< "$LINE"
    echo -n "${RECORD[0]} ["
    if [ "${RECORD[3]}" == 'text' ]; then echo -n TEXT
    elif [ "${RECORD[3]}" == 'check' ]; then echo -n BOOL
    elif [ "${RECORD[3]}" == 'option' ]; then
      if [ "${RECORD[4]}" ]; then echo -n "ENUM(${RECORD[4]})"
      else echo -n "TEXT"; fi
    fi
    echo "] - ${RECORD[2]}"
    if [ "${RECORD[1]}" ]; then echo "  ${RECORD[1]}"
    else echo "<none>"; fi
    echo ""
  done
}

################################### COMMANDS ###################################
function interactive {
  tput smcup

  RESULT=`dialog \
  --backtitle "$PROGRAM_NAME" \
  --title "Build List Box" \
  --visit-items \
  --buildlist "Text" 0 0 0 \
    "it1" "Initially selected"     on \
    "it2" "Initially not selected" off 2>&1 1>&3`

  dialog \
  --backtitle "$PROGRAM_NAME" \
  --title "Message Box" \
  --msgbox "You've selected: $RESULT" 0 0

  tput rmcup

}

function version {
  echo $PROGRAM_NAME
  echo "Version $PROGRAM_VERSION"
  echo "Â© 2018 Mateusz Karcz. All rights reserved."
  echo "Licensed under the MIT License."
}

function help {
  echo "Program help"
}

function update {
  # $1 (optional) - alternative remote repository URL
  check_wget

  if [ "$1" ]; then
    REPO_URL="$1"
    echo -n "$1" > "${REPO_LOCAL}remote"
  fi

  FILE="${REPO_LOCAL}bases.csv"
  URL="${REPO_URL}bases.csv"

  mkdir -p `dirname "$FILE"`

  if [ -f "$FILE" ]; then
    HTTP_LAST_MODIFIED=`http_header "Last-Modified"`
    if [ $(date -d "$HTTP_LAST_MODIFIED" +%s) -gt $(stat -c %Y "$FILE") ]; then
      rm "$FILE"
    else
      echo "Repository already up to date."
    fi
  fi

  if [ ! -f "$FILE" ]; then
    echo "Updating the repository..."
    http_download
    if [ -f "$FILE" ]; then
      echo "Repository update completed."
    else
      echo "Cannot update repository!" >&2
      exit 1
    fi
  fi
}

function bases {
  FILE="${REPO_LOCAL}bases.csv"

  if [ ! -f "$FILE" ]; then update; fi

  print_list
}

function base {
  if [ -z "$1" -o \( "${1:0:1}" == '-' \) ]; then

    if [ -f ".osprep/base" ]; then
      cat ".osprep/base"
      echo ''
    else
      echo "<none>"
    fi

  else

    FILE="${REPO_LOCAL}bases.csv"

    if [ ! -f "$FILE" ]; then
      echo "No repository! Update first." >&2
      exit 1
    fi

    find_package $1
    if [ "$FOUND" ]; then
      echo -n "$FOUND" > ".osprep/base"
      echo "Successfully selected \`$FOUND\` as the base package."
    else
      echo "Cannot find base package: \`$1\`!" >&2
      exit 1
    fi

  fi
}

function packages {
  BASE=`base`
  if [ "$BASE" == "<none>" ]; then
    echo "Select base package first!" >&2
    exit 1
  fi

  CSV_PATH="`rdn_to_path "$BASE"`.csv"

  URL="${REPO_URL}${CSV_PATH}"
  FILE="${REPO_LOCAL}${CSV_PATH}"

  mkdir -p `dirname "$FILE"`

  if [ -f "$FILE" -a \( $OPT_LOCAL == false \) ]; then
    check_wget
    HTTP_LAST_MODIFIED=`http_header "Last-Modified"`
    if [ $(date -d "$HTTP_LAST_MODIFIED" +%s) -gt $(stat -c %Y "$FILE") ]; then
      rm "$FILE"
      echo "New package list in the remote repository."
    fi
  fi

  if [ ! -f "$FILE" -a \( $OPT_LOCAL == true \) ]; then
    echo "No package list in the local repository!" >&2
    exit 1
  fi

  if [ ! -f "$FILE" ]; then
    check_wget
    echo "Fetching the package list..."
    http_download
    if [ -f "$FILE" ]; then
      echo "Package list update completed."
    else
      echo "Cannot update the package list!" >&2
      exit 1
    fi
  fi

  print_list
}

function add {
  BASE=`base`
  if [ "$BASE" == "<none>" ]; then
    echo "Select base package first!" >&2
    exit 1
  fi

  CSV_PATH="`rdn_to_path "$BASE"`.csv"
  FILE="${REPO_LOCAL}${CSV_PATH}"

  if [ ! -f "$FILE" ]; then
    echo "Cannot read the package list! Run \`osprep packages\` first." >&2
    exit 1
  fi

  find_package $1
  if [ "$FOUND" ]; then
    touch ".osprep/packages"
    if [ `grep "^$FOUND" < ".osprep/packages"` ]; then
      echo "Package \`$FOUND\` has been selected before."
      exit 0
    fi

    echo "$FOUND" >> ".osprep/packages"
    echo "Successfully added \`$FOUND\` package to the project."
  else
    echo "Cannot find package: \`$1\`!" >&2
    exit 1
  fi
}

function remove {
  FILE=".osprep/packages"
  FOUND=`grep -E "^$1(~.*)?$" < "$FILE"`

  if [ "$FOUND" ]; then
    TMP=`mktemp`
    grep -v -E "^$1(~.*)?$" < "$FILE" > "$TMP"
    rm "$FILE"
    mv "$TMP" "$FILE"

    echo -n "Successfully removed from the project the following packages: "
    echo $FOUND
  else
    echo "Cannot find any packages matching \`$1\` in the project!" >&2
    exit 1
  fi
}

function list {
  BASE=`base`
  if [ "$BASE" == "<none>" ]; then
    echo "Select base package first!" >&2
    exit 1
  fi

  CSV_PATH="`rdn_to_path "$BASE"`.csv"
  FILE="${REPO_LOCAL}${CSV_PATH}"

  if [ ! -f "$FILE" ]; then
    echo "Cannot read the package list! Run \`osprep packages\` first." >&2
    exit 1
  fi

  TMP=`mktemp`
  touch ".osprep/packages"
  while read LINE; do
    IFS='~' read -r -a SPLIT <<< "$LINE"
    grep -E "^${SPLIT[0]};${SPLIT[1]};" "$FILE" >> "$TMP"
  done < ".osprep/packages"

  FILE="$TMP"
  print_list
  rm "$TMP"
}

function snap {
  check_wget

  BASE=`base`
  if [ "$BASE" == "<none>" ]; then
    echo "Select base package first!" >&2
    exit 1
  fi

  GENERAL_PATH=`rdn_to_path "$BASE"`
  PKG_PATH="${GENERAL_PATH}.txz"
  CFG_PATH=".osprep/settings/${GENERAL_PATH}.mk"
  FILE="${REPO_LOCAL}${PKG_PATH}"
  URL="${REPO_URL}${PKG_PATH}"
  TARGET_DIR="${REPO_LOCAL}${GENERAL_PATH}"

  echo -n "Fetching base package \`$BASE\`... "
  download_package
  extract_package
  mkdir -p `dirname "$CFG_PATH"`
  cp "${TARGET_DIR}/settings.mk" "$CFG_PATH"

  touch ".osprep/packages"
  while read LINE; do
    GENERAL_PATH=`rdn_to_path "$LINE"`
    PKG_PATH="${GENERAL_PATH}.txz"
    CFG_PATH=".osprep/settings/${GENERAL_PATH}.mk"
    FILE="${REPO_LOCAL}${PKG_PATH}"
    URL="${REPO_URL}${PKG_PATH}"
    TARGET_DIR="${REPO_LOCAL}${GENERAL_PATH}" 

    echo -n "Fetching package \`$LINE\`... "
    download_package
    extract_package
    mkdir -p `dirname "$CFG_PATH"`
    cp "${TARGET_DIR}/settings.mk" "$CFG_PATH"
  done < ".osprep/packages"
}

function set {
  # $1 (optional) - key to get/set
  # $2 (optional) - new value

  # See all settings
  if [ -z $1 ]; then
    find ".osprep/settings" -name "*.mk" | while read FILE; do
      if [ $OPT_FORMAT == 'csv' ]; then mk_to_csv;
      else mk_to_csv | beautify_settings; fi
    done

  # Access settings for one package
  elif [ `echo "$1" | grep -P '^[a-z0-9]+(\.[a-z0-9]+)*~[a-z0-9]+(\.[a-z0-9]+)*(::[a-z0-9]+)?$'` ]; then
  
    # Get values
    if [ -z $2 ]; then
      # We've found Paamayim Nekudotayim, so the user wants just one value
      if [ `echo "$1" | grep '::'` ]; then
        PACKAGE=`echo "$1" | sed 's/::.*//'`
        FILE=".osprep/settings/`rdn_to_path "$PACKAGE"`.mk"
        mk_to_csv | grep "^$1;" | cut -d ';' -f 2

      # No Paamayim Nekudotayim, so the user wants EVERYTHING
      else
        FILE=".osprep/settings/`rdn_to_path "$1"`.mk"
        if [ $OPT_FORMAT == 'csv' ]; then mk_to_csv;
        else mk_to_csv | beautify_settings; fi
      fi

    # The user wants to modify a value
    elif [ `echo "$1" | grep '::'` ]; then
      PACKAGE=`echo "$1" | sed 's/::.*//'`
      FILE=".osprep/settings/`rdn_to_path "$PACKAGE"`.mk"
      if [ ! -f "$FILE" ]; then
        echo "Cannot set value for package \`$PACKAGE\`! Package not found." >&2
        exit 1
      fi

      LINE=`mk_to_csv | grep "^$1;"`
      if [ -z "$LINE" ]; then
        echo "Cannot set value for \`$1\`! Key not found." >&2
        exit 1
      fi

      IFS=';' read -r -a RECORD <<< "$LINE"
      RECORD[1]="$2"
      record_to_mk

    # No Paamayim Nekudotayim means a mistake here...
    else
      echo "Cannot change value of a package!" >&2
      exit 1

    fi

  # The user screwed up
  else
    echo "\`$1\` is not a valid key or package name!" >&2
    exit 1

  fi
}

function reset {
  return
}

function apply {
  check_make

  BASE=`base`
  if [ "$BASE" == "<none>" ]; then
    echo "Select base package first!" >&2
    exit 1
  fi
  TARGET="target"
  if [ "$1" ]; then TARGET="$1"; fi
  rm -rf "$TARGET"
  mkdir -p "$TARGET"

  MAKEDIR=".osprep/make"
  rm -rf "$MAKEDIR"
  mkdir -p "$MAKEDIR"

  touch ".osprep/packages"
  while read LINE; do prepare_apply "$LINE"; done < ".osprep/packages"

  echo -e "Processing packages..."
  RESTORE_DIR="$PWD"
  find `realpath "$MAKEDIR"` -type d | grep -E '~[^/]+$' | while read LINE; do
    echo -e "\nProcessing $LINE..."
    cd "$LINE"
    make apply
    if [ $? -ne 0 ]; then exit 1; fi
  done
  cd "$RESTORE_DIR"

  echo -e "\nProcessing base package..."
  prepare_apply "$BASE"
  cd "${MAKEDIR}/`rdn_to_path "$BASE"`"
  make apply
  cd "$RESTORE_DIR"
}

function discard {
  rm -f ".osprep/packages"
  rm -rf ".osprep/settings"
  rm -rf ".osprep/make"
}

function image {
  # make -C <dir> image
  return
}

######################### SCRIPT ARGUMENTS PROCESSING ##########################
exec 3>&1

if [ -f "${REPO_LOCAL}remote" ]; then REPO_URL=`cat ${REPO_LOCAL}remote`; fi

for i in "$@"; do
  case $i in

    --local|-l ) OPT_LOCAL=true     ;;
    --format=* ) OPT_FORMAT=${i#*=} ;;

  esac
done

case $1 in

  '' ) interactive ;;

  --version|-v   ) version     ;;
  --help|-h|help ) help        ;;

  update   ) update   "$2";;
  bases    ) bases    "$2";;
  base     ) base     "$2";;
  packages ) packages "$2";;
  add      ) add      "$2";;
  remove   ) remove   "$2";;
  list     ) list     "$2";;
  snap     ) snap     "$2";;
  set      ) set      "$2" "$3";;
  reset    ) reset    "$2";;
  apply    ) apply    "$2";;
  discard  ) discard  "$2";;
  image    ) image    "$2";;

  *)
    if [ $OPT_LOCAL = true ]; then
      interactive
    else
      echo "\`$1\` is not a valid OS Preparation Utility command!" >&2
      exit 1
    fi

esac
